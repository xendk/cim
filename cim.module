<?php

/**
 * @file
 * Configuration interchange and management.
 */

/**
 * Implements hook_menu().
 */
function cim_menu() {
  $items['admin/config/development/cim'] = array(
    'title' => 'Configuration Interchange and Management',
    'page callback' => 'cim_admin_list',
    // @todo proper permissions.
    'access arguments' => array('administer site configuration'),
    'file' => 'cim.admin.inc',
  );

  $items['admin/config/development/cim/list'] = array(
    'title' => 'List',
    'description' => 'List snapshots',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
    'file' => 'cim.admin.inc',
  );

  $items['admin/config/development/cim/test'] = array(
    'title' => 'Teststuff',
    'page callback' => 'cim_testing',
    // @todo proper permissions.
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'cim.admin.inc',
  );

  return $items;
}

/**
 * Interface for interacting with snapshots and configuration.
 */
interface SnapshotInterface {
  /**
   * Checks if a given config path exists.
   */
  function exists($path);

  /**
   * Get the value of a config item.
   */
  function get($path);

  /**
   * Set the value of a config item.
   */
  function set($path, $value);

  /**
   * Clear (unset) a config item.
   */
  function clear($path);

  /**
   * Convert to the common array format.
   */
  function toArray();

  /* function commit(); */
}

/**
 * Implements SnapshotInterface using an internal array for storage.
 */
class ArraySnapshot implements SnapshotInterface {
  /**
   * The configuration.
   */
  protected $config = array();

  /**
   * Constructor. Takes an array in the common format.
   */
  function __construct($array) {
    if (!is_array($array)) {
      throw new Exception('Non-array passed to ArraySnapshot::__construct.');
    }
    $this->config = $array;
  }

  /**
   * Implements SnapshotInterface::exists().
   */
  function exists($path) {
    return drupal_array_nested_key_exists($this->config, $path);
  }

  /**
   * Implements SnapshotInterface::get().
   */
  function get($path) {
    return drupal_array_get_nested_value($this->config, $path);
  }

  /**
   * Implements SnapshotInterface::set().
   */
  function set($path, $value) {
    drupal_array_set_nested_value($this->config, $path, $value);
  }

  /**
   * Implements SnapshotInterface::clear().
   */
  function clear($path) {
    $name = array_pop($path);
    $ref = &$this->config;
    foreach ($path as $parent) {
      $ref = &$ref[$parent];
    }
    unset($ref[$name]);
  }

  /**
   * Implements SnapshotInterface::toArray().
   */
  function toArray() {
    return $this->config;
  }
}

/**
 * SnapshotInterface to the config system.
 */
class Config implements SnapshotInterface {
  /**
   * Array of DrupalConfig objects.
   */
  protected $configs = array();

  /**
   * Constructor.
   */
  function __construct() {
    $cnf = config_get_storage_names_with_prefix();
    foreach ($cnf as $key) {
      $this->configs[$key] = config($key);
    }
  }

  /**
   * Implements SnapshotInterface::exists().
   */
  function exists($path) {
    $name = array_shift($path);
    if (!isset($this->configs[$name])) {
      return FALSE;
    }

    return $this->configs[$name]->get(join('.', $path)) !== NULL ? TRUE : FALSE;
  }

  /**
   * Implements SnapshotInterface::get().
   */
  function get($path) {
    $name = array_shift($path);
    if (!isset($this->configs[$name])) {
      return NULL;
    }

    return $this->configs[$name]->get(join('.', $path));
  }

  /**
   * Implements SnapshotInterface::set().
   */
  function set($path, $value) {
    $name = array_shift($path);

    return $this->configs[$name]->set(join('.', $path), $value);
  }

  /**
   * Implements SnapshotInterface::clear().
   */
  function clear($path) {
    $name = array_shift($path);
    if (!isset($this->configs[$name])) {
      return;
    }

    $this->configs[$name]->clear(join('.', $path));
  }

  /**
   * Implements SnapshotInterface::toArray().
   */
  function toArray() {
    $cnf = config_get_storage_names_with_prefix();
    $config = array();
    foreach ($this->configs as $key => $conf) {
      $config[$key] = $conf->get();
    }
    return $config;
  }
}

/**
 * Represents a single change to a snapshot.
 */
class Difference {
  /**
   * Special NULL value so we can distinguish NULL and really non-existing.
   * md5('Difference::EMPTY')
   */
  const NULL = 'f8ce859e75fec78d568b2800b99c9854';

  /**
   * The config path changed.
   */
  public $path;

  /**
   * Existing value.
   */
  public $a;

  /**
   * New value.
   */
  public $b;

  /**
   * Create a new difference.
   */
  function __construct($path, $a, $b) {
    $this->path = $path;
    $this->a = $a;
    $this->b = $b;
  }

  /**
   * Test if difference applies to snapshot.
   */
  public function appliesTo(SnapshotInterface $snapshot) {
    if ($this->noopCheck($snapshot)) {
      return TRUE;
    }
    if ($this->a === self::NULL) {
      return !$snapshot->exists($this->path);
    }
    return $snapshot->get($this->path) === $this->a;
  }

  /**
   * Apply difference to snapshot.
   */
  public function apply(SnapshotInterface $snapshot) {
    if (!$this->appliesTo($snapshot)) {
      return FALSE;
    }
    if ($this->b === self::NULL) {
      $snapshot->clear($this->path);
    }
    else {
      $snapshot->set($this->path, $this->b);
    }
    return $snapshot;
  }

  /**
   * Count the additions/changes/removals of change.
   */
  public function diff3Stat() {
    $stat = array(0, 0, 0);
    if ($this->a === self::NULL) {
      // Additions.
      $stat[0] = sizeof($this->b);
    }
    elseif ($this->b === self::NULL) {
      // Removals.
      $stat[2] = sizeof($this->a);
    }
    else {
      // Counts as X changes and Y additions/removals.
      $a = sizeof($this->a);
      $b = sizeof($this->b);
      $changes = min($a, $b);
      $diff = max($a, $b) - $changes;
      if ($a > $b) {
        $stat[1] = $diff;
      }
      else {
        $stat[0] = $diff;
      }
      $stat[1] = $changes;
    }
    return $stat;
  }

  /**
   * Test if difference is already implemented.
   */
  protected function noopCheck(SnapshotInterface $snapshot) {
    if ($this->b === self::NULL) {
      return !$snapshot->exists($this->path);
    }
    return $snapshot->get($this->path) === $this->b;
  }

}

/**
 * Represents a set of changes to a configuration.
 */
class Changeset {
  /**
   * Parent snapshot.
   */
  protected $parent = "";

  /**
   * Array of Differences.
   */
  protected $changes;

  /**
   * Create a changeset from the difference between two snapshots.
   *
   * @return Changeset|NULL
   *   changeset or NULL if no changes detected.
   */
  public static function fromDiff($a, $b, $parent = "") {
    $changes = Changeset::diff($a, $b);
    if ($changes) {
      $changeset = new Changeset();
      $changeset->parent = $parent;
      $changeset->changes = $changes;
      return $changeset;
    }
    return NULL;
  }

  /**
   * Compute the difference between two snapshots.
   */
  public static function diff($a, $b, $prefix = array()) {
    $diff = array();
    $str_prefix = join('.', $prefix);
    foreach (array('a', 'b') as $var) {
      if (!is_array(${$var})) {
        if (${$var} instanceof SnapshotInterface) {
          ${$var} = ${$var}->toArray();
        }
        else {
          throw new Exception("Argument to diff not an array or instance of SnapshotInterface.");
        }
      }
    }
    $common_keys = array_intersect_key($a, $b);
    foreach ($common_keys as $key => $dummy) {
      if (is_array($a[$key]) && is_array($b[$key])) {
        $diff = array_merge($diff, Changeset::diff($a[$key], $b[$key], array_merge($prefix, array($key))));
      }
      else {
        if ($a[$key] !== $b[$key]) {
          $diff[] = new Difference(array_merge($prefix, array($key)), $a[$key], $b[$key]);
        }
      }
    }

    $a_keys = array_diff_key($a, $common_keys);
    foreach ($a_keys as $key => $value) {
      $diff[] = new Difference(array_merge($prefix, array($key)), $value, Difference::NULL);
    }

    $b_keys = array_diff_key($b, $common_keys);
    foreach ($b_keys as $key => $value) {
      $diff[] = new Difference(array_merge($prefix, array($key)), Difference::NULL, $value);
    }

    return array_filter($diff);
  }

  /**
   * Returns the parent of this changeset.
   */
  public function parent() {
    return $this->parent;
  }

  /**
   * Test if this changeset will apply to the given snapshot.
   */
  public function appliesTo(SnapshotInterface $snapshot) {
    foreach ($this->changes as $change) {
      if (!$change->appliesTo($snapshot)) {
        return FALSE;
      }
    }
    return TRUE;
  }

  /**
   * Applies changeset to snapshot.
   */
  public function apply(SnapshotInterface $snapshot) {
    foreach ($this->changes as $change) {
      if (!($snapshot = $change->apply($snapshot))) {
        return FALSE;
      }
    }
    return $snapshot;
  }

  /**
   * Return the identifier for this changeset.
   */
  public function identifier() {
    $string = $this->parent;
    foreach ($this->changes as $change) {
      $string .= serialize($change);
    }
    return hash('sha256', $string);
  }

  /**
   * Count the additions/changes/removals of changeset.
   */
  public function diff3Stat() {
    $total = array(0, 0, 0);
    foreach ($this->changes as $change) {
      $stat = $change->diff3Stat();
      $total[0] += $stat[0];
      $total[1] += $stat[1];
      $total[2] += $stat[2];
    }
    return $total;
  }
}

/**
 * Manages snapshots.
 */
class SnapshotController {
  /**
   * The number of changesets between saving a full dump of configuration.
   */
  const FULL_DUMP_FREQUENCY = 3;

  /**
   * Take a snapshot.
   */
  public function save() {
    $fulldump = FALSE;
    $config = new Config();
    $latest_row = $this->latest();
    if ($latest_row) {
      list($depth, $previous_dump) = $this->latestDump($latest_row);
      $changeset = Changeset::fromDiff($previous_dump, $config, $latest_row->identifier);
      if ($depth >= self::FULL_DUMP_FREQUENCY) {
        $fulldump = TRUE;
      }
    }
    else {
      $fulldump = TRUE;
      $changeset = Changeset::fromDiff(array(), $config);
    }
    if ($changeset) {
      $snapshot = new stdClass();
      if ($fulldump) {
        $snapshot->dump = $config->toArray();
      }
      $snapshot->changeset = $changeset;
      $snapshot->identifier = $changeset->identifier();
      $snapshot->parent = $changeset->parent();
      $snapshot->created = REQUEST_TIME;
      drupal_write_record('cim', $snapshot);
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Load a snapshot.
   */
  public function load($identifier) {
    $row = db_select('cim', 'c')
      ->fields('c')
      ->condition('identifier', $identifier)
      ->execute()->fetch();
    if ($row) {
      $row->changeset = unserialize($row->changeset);
      if (isset($row->dump)) {
        $row->dump = unserialize($row->dump);
      }
    }
    return $row;
  }

  /**
   * List snapshots in reverse chronological order.
   *
   * @param int $num
   *   Number of changesets to list.
   * @param string $start
   *   Identifier of the changeset to start from.
   */
  public function listing($num = 10, $start = NULL) {
    $result = array();
    if ($start) {
      $row = $this->load($start);
    }
    else {
      $row = $this->latest();
    }
    if (!$row) {
      return $result;
    }

    while (sizeof($result) < $num) {
      $row = $this->load($row->parent);
      if (!$row) {
        break;
      }
      $result[] = $row;
    }
    return $result;
  }

  /**
   * Get the latest changeset.
   */
  public function latest() {
    $latest = db_select('cim', 'c')
      ->fields('c')
      ->orderBy('created', 'DESC')
      ->orderBy('cid', 'DESC')
      ->range(0, 1)
      ->execute()->fetch();
    if ($latest) {
      $latest->changeset = unserialize($latest->changeset);
      if (!empty($latest->dump)) {
        $latest->dump = unserialize($latest->dump);
      }
    }
    return $latest;
  }

  /**
   * Get a config dump from a changeset.
   *
   * Finds the last full dump and applies the following changesets, up to the
   * supplied changset.
   */
  public function latestDump($changeset_row) {
    if (empty($changeset_row->dump)) {
      // Loop back through history until we find a dump.
      $changesets = array();
      $cur_changeset = $changeset_row;
      while (empty($cur_changeset->dump)) {
        $changesets[] = $cur_changeset->cid;
        $cur_changeset = db_select('cim', 'c')
          ->fields('c', array('cid', 'identifier', 'parent', 'dump'))
          ->condition('identifier', $cur_changeset->parent)
          ->execute()->fetch();
        if (!$cur_changeset) {
          throw new Exception('CIM: Broken history.');
        }
      }

      if (empty($cur_changeset->dump)) {
        throw new Exception('CIM: Broken history, could not find base dump.');
      }

      $depth = 0;
      $dump = new ArraySnapshot(unserialize($cur_changeset->dump));
      // Now load and apply them one by one (to conserve memory) in reverse.
      while ($cid = array_pop($changesets)) {
        $cur_changeset = db_select('cim', 'c')
          ->fields('c', array('identifier', 'changeset'))
          ->condition('cid', $cid)
          ->execute()->fetch();

        $changeset = unserialize($cur_changeset->changeset);
        $dump = $changeset->apply($dump);
        $depth++;

        // Hint for garbage collection.
        unset($cur_changeset);
      }

      return array($depth, $dump);
    }
    return array(0, $changeset_row->dump);
  }
}
